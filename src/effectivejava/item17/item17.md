# Item17. 변경 가능성을 최소화 하라

## 불변 클래스

- 인스턴스의 내부 값을 수정할 수 없는 클래스.
- 불변 인스턴스에 간직된 `정보는 고정`되어 객체가 파괴되는 순간까지 `절대 달라지지 않는다`.
- String, 기본타입의 박싱된 클래스, BigInteger, BigDecimal 등

## 불변 클래스 예시 - 복소수 클래스

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9053bc9a-a9ed-4610-ba6b-531b95ca4d9b/Untitled.png)

- 복소수 클래스의 Complex 일부
- Plus method → 인스턴스 자신은 수정하지 않고 새로운 Complex 인스턴스를 만들어 반환
- 피연산자에 함수를 적용하여 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴 → 함수형 프로그래밍
    - 코드에서 불변이 되는 영역의 비율이 높아지는 장점

## 불변 클래스 특징

1. 불변 객체끼리는 내부 데이터를 공유할 수 있다.
    - BigInteger Class

      ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0dfa2d79-37b5-4055-b5ba-559cbcc3f517/Untitled.png)

        - 내부에서 값의 부호(int)와 크기(int[])를 따로 표현함.
        - negate 메서드는 크기가 같고 부호만 반대인 새로운 BigInteger를 생성
        - 이때 , 배열은 방어적 복사본을 복사하지 않고 원본 인스턴스와 공유해도됨.
        - 그 결과 새로운 BigInteger 인스턴스도 원본 인스턴스가 가리키는 내부 배열을 그대로 가리킴
2. 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.
    - 값이 바뀌지 않는 구성요소들로 이뤄진 객체라면 그 구조가 아무리 복잡해도 불변식을 유지하기 훨씬 수월함.
    - ex) 불변 객체는 맵의 키와 원소로 쓰기 좋음.
        - 맵이나 집합은 안에 담긴 값이 바뀌면 불변식이 허물어지는데, 불변 객체를 새용하면 그런 걱정은 하지 않아도됨
3. 실패 원자성을 제공
    - 메서드에서 예외가 발생한 후에도 그 객체는 여전히 호출 전과 유효한 상태여야 한다는 성질
    - setter가 있거나 내부 필드 값을 변경 가능한 메서드가 존재한다면, 여러 필드의 값을 변경하다가 예외 시 그 변경되었던 값들이 다 기존의 값으로 변경 되어야함
    - 불변 객체의 경우 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없음


## 불변 클래스 장점

1. 불변 객체는 단순함
    - 생성된 시점의 상태를 파괴될 때까지 그대로 간직
2. 쓰레드 안전하여 동기화 할 필요 없음.
    - 여러 스레드가 동시에 사용해도 절대 훼손되지 않음
    - → 클래스를 스레드 세이프하게 만드는 가장 쉬운 방법
3. 안심하고 공유할 수 있음.
    - 한번 만든 인스턴스를 최대한 `재활용`하기를 권함. (캐싱)
    - 가장 쉬운 재활용 방법 → 자주 쓰이는 값들을 `상수`로 제공

## 불변 클래스 단점

- 값이 다르면 반드시 독립된 객체로 만들어줘야한다
    - 값의 가짓수가 많다면 이를 모두 만드는데 큰 비용을 매번 처리 필요

## 클래스를 불변으로 만들기 위한 다섯가지 규약

1. 객체의 상태를 변경하는 메서드를 제공하지 않아야 한다.
    - ex) setter
2. 클래스를 확장할 수 없도록 한다.
    - 자신을 상속하는 것을 막는 2가지 방법
    - 하위 클래스에서 부주의하게 혹은 나쁜 의도로 객체의 상태를 변하게 만드는 상황을 막아준다.

      a. 클래스를 final로 선언하는 방법

      ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dd67c295-22f5-4ed3-be2e-791e265822a2/Untitled.png)

      b. `생성자 대신 정적 팩터리 메서드 사용하는 방법`

      ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/62a88e37-8f3c-41e4-9877-184f251e3127/Untitled.png)

        - 모든 생성자를 private or package-private로 선언하고, public 정적 펙토리를 제공
        - 패키지 바깥의 클라이언트에서 바라본 이 불변 객체는 사실상 final
        - public이나 protected 생성자가 없으니 다른 패키지에서 클래스를 확장하는게 불가능하기 떄문
        - 정적 팩터리 방식은 다수의 구현 클래스를 활용한 유연성을 제공하고, 객체 캐싱 기능을 추가해 성능을 끌어올릴 수 있음.
        1. 모든 필드를 final로 선언
            - 시스템이 강제하는 수단을 이용해 `설계자의 의도를 명확히` 드러내는 방법
            - 새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제없이 동작하게끔 보장하는데도 필요
        2. 모든 필드를 private로 선언
            - 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근하여 수정하는 일을 막아줌
            - public final로만 선언해도 불변 객체가 되지만, 내부 표현을 바꾸지는 못하므로 권하지는 않음
        3. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
            - 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야함.
            - 접근자 메서드가 그 필드를 그대로 반환해도 안됨. 생성자, 접근자, readObject 모두에서 방어적 복사를 수행해야함

      > **방어적 복사**
      >
      > - 생성자의 인자로 받은 객체의 복사본을 만들어 내부 필드를 초기화하거나, getter메서드에서 내부의 객체를 반환할 때, 객체의 복사본을 만들어 반환하는 것.
      > - 방어적 복사를 사용할 경우, 외부에서 객체를 변경해도 내부의 객체는 변경되지 않는다.


## 정리

1. 클래스는 꼭 필요한 경우가 아니면 `불변`으로 , 불변으로 만들 수 없다면 `변경 부분을 최소한`으로
    - getter이 있다고 무조건 setter 생성 않기
2. 다른 합당한 이유가 없다면 모든 필드는 `private final`
    - 객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고, 오류가 생길 가능성이 줄어듦
    - 그렇기에 가능하다면 변경해야할 필드를 뺀 나머지 모두를 `final`로
3. 생성자는 불변식 설정이 모두 완료된 `초기화가 완벽히 끝난 상태의 객체를 생성`
    - 확실한 이유가 없다면 생성자와 정적 펙터리 메서드 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안됨.
    - 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 복잡성만 커지고 이점은 거의 없기 때문에 지양 필요